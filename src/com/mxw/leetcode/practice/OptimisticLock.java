package com.mxw.leetcode.practice;

public class OptimisticLock {

    /**
     * 悲观锁:每次拿都以为要修改，所以只能一个人拿
     * synchronized:在它的保护下只有一个人进行操作
     * 线程切换消耗高->java线程映射系统线程->系统线程切换从用户态转换到内核态
     * 6以后优化：
     * 1.自旋锁 ，2.适应性自旋锁 ， 3.锁消除 ，4.锁粗化 ，5.偏向锁、6.轻量级锁
     * 使用场景： 2 种 ：方法，代码快
     * 锁的范围：1.当前实例对象：实例方法，代码块传入对象，2.当前class：静态方法，代码块传入类
     *
     * 代码快原理分析：
     * 两个指令：
     * monitorenter（代码块开始位置）：获取失败阻塞等待
     * 线程获取对象监视器（monitor：基于 C++实现，每个对象都内置）
     * 将锁的计数器加1
     * monitorexit（代码块结束位置）：释放锁
     * 计数器减1
     *
     * 方法原理分析：acc_synchronized 标识
     *
     *
     * 乐观锁：每个人都只是拿来读，有人修改了则对比一下（版本号），看谁先修改的快
     *  CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令
     *  CAS 经常会用到自旋操作：
         private AtomicInteger count = new AtomicInteger(0);
             public void increment() {
                 int oldValue = count.get();
                 while (!count.compareAndSet(oldValue, oldValue + 1)) {
                    oldValue = count.get();
                 }
             }

             public int getCount() {
                 return count.get();
             }
     */

    /**
     * 对象组成部分：
     *  对象头：
           Mark Word（标记字段）：存储对象自身的运行时数据：hashcode，年龄，锁标志位
           class Point（类型指针）：
     *  实例数据：类信息，父信息
     *  字节对齐：
     *
     * 锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。
     * 对synchronized在不同的场景，有不同的状态模式。
     * 偏向锁：偏向于某个线程，该线程可直接获取锁，如果有其它线程竞争时，转换为轻量级锁或重量级锁状态。
     * 偏向锁是Java虚拟机为了优化同步操作而引入的一种锁机制，它的基本思想是：如果一个线程获得了锁，那么在未来一段时间内，再次请求该锁，就不需要再次进行竞争，而是直接获取锁。这种机制在程序中会提高同步操作的效率。
     * 实现上，偏向锁是通过在对象头中存储标志位来实现的。对象头中有一个偏向锁标志位，当对象被创建时，偏向锁标志位默认为0，表示该对象没有被任何线程访问过。当线程访问该对象时，偏向锁标志位就会被置为1，表示该对象已经被访问过了。同时，还会在该对象头中记录该线程的ID，表示该线程获得了该对象的锁。
     * 当其他线程也要访问该对象时，它们会先检查该对象头中的偏向锁标志位是否为1，如果是，则说明已经有线程持有该对象的锁，此时只需要判断持有锁的线程是否为当前线程即可，如果是，则直接获取锁；如果不是，则说明已经有其他线程持有该对象的锁，此时需要进入轻量级锁的状态，通过自旋来等待持有锁的线程释放锁。
     * 如果在未来的使用中，偏向锁的状态被多个线程使用，那么偏向锁就会失效，此时对象头中的标志位会被重置为0，表示该对象需要进入常规的轻量级锁和重量级锁的状态，以确保多个线程之间的正确性。
     *
     *
     * 偏向锁与轻量级锁之间的转换是通过CAS操作来实现的
     *
     *
     * 轻量级锁在竞争不激烈的情况下可以提高性能，但如果发生竞争激烈的情况，会导致大量的自旋，浪费 CPU 资源。当自旋次数达到一定的阈值时，轻量级锁会膨胀成重量级锁，此时线程会进入阻塞状态，等待获取锁的线程释放锁。
     * 具体来说，当一个线程尝试获取轻量级锁失败时，会先自旋一定的次数尝试获取锁，如果自旋成功，则直接进入临界区执行，否则将轻量级锁膨胀成重量级锁。在膨胀时，虚拟机会在堆中为对象分配一个重量级锁记录，用来存储锁对象的信息，比如拥有该锁的线程和互斥信号量等。同时，虚拟机会将对象头中的标志位设置成重量级锁标志。
     * 膨胀到重量级锁后，所有尝试获取锁的线程都会被阻塞，而不是自旋。当锁的持有者释放锁后，虚拟机会唤醒所有阻塞在该锁上的线程，然后它们会竞争该锁，竞争成功的线程会进入临界区，其它线程则会被再次阻塞。因为线程在阻塞时需要进行上下文切换，所以重量级锁的性能较低，只适用于竞争激烈的场景。
     *
     */
}
